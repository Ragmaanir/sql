<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 0.27.1-dev">


<link href="css/style.css" rel="stylesheet" type="text/css">

<script type="text/javascript" src="js/doc.js"></script>
<script type="text/javascript">
  CrystalDoc.base_path = "";
</script>

  <meta id="repository-name" content="github.com/atomframework/model">
  <title>README - github.com/atomframework/model</title>
</head>
<body>

<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="repository-links">
      <a href="index.html">README</a>
    </div>
  </div>

  <div class="search-results" class="hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class="parent " data-id="github.com/atomframework/model/Atom" data-name="atom">
      <a href="Atom.html">Atom</a>
      
        <ul>
  
  <li class="parent " data-id="github.com/atomframework/model/Atom/Model" data-name="atom::model">
      <a href="Atom/Model.html">Model</a>
      
        <ul>
  
  <li class=" " data-id="github.com/atomframework/model/Atom/Model/DefaultValueError" data-name="atom::model::defaultvalueerror">
      <a href="Atom/Model/DefaultValueError.html">DefaultValueError</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/atomframework/model/Atom/Query" data-name="atom::query(t)">
      <a href="Atom/Query.html">Query</a>
      
        <ul>
  
  <li class=" " data-id="github.com/atomframework/model/Atom/Query/Having" data-name="atom::query::having">
      <a href="Atom/Query/Having.html">Having</a>
      
    </li>
  
  <li class=" " data-id="github.com/atomframework/model/Atom/Query/JoinType" data-name="atom::query::jointype">
      <a href="Atom/Query/JoinType.html">JoinType</a>
      
    </li>
  
  <li class=" " data-id="github.com/atomframework/model/Atom/Query/LatestWherishClause" data-name="atom::query::latestwherishclause">
      <a href="Atom/Query/LatestWherishClause.html">LatestWherishClause</a>
      
    </li>
  
  <li class=" " data-id="github.com/atomframework/model/Atom/Query/Order" data-name="atom::query::order">
      <a href="Atom/Query/Order.html">Order</a>
      
    </li>
  
  <li class=" " data-id="github.com/atomframework/model/Atom/Query/Type" data-name="atom::query::type">
      <a href="Atom/Query/Type.html">Type</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/atomframework/model/Atom/Repository" data-name="atom::repository">
      <a href="Atom/Repository.html">Repository</a>
      
        <ul>
  
  <li class="parent " data-id="github.com/atomframework/model/Atom/Repository/Logger" data-name="atom::repository::logger">
      <a href="Atom/Repository/Logger.html">Logger</a>
      
        <ul>
  
  <li class=" " data-id="github.com/atomframework/model/Atom/Repository/Logger/Dummy" data-name="atom::repository::logger::dummy">
      <a href="Atom/Repository/Logger/Dummy.html">Dummy</a>
      
    </li>
  
  <li class=" " data-id="github.com/atomframework/model/Atom/Repository/Logger/IO" data-name="atom::repository::logger::io">
      <a href="Atom/Repository/Logger/IO.html">IO</a>
      
    </li>
  
  <li class=" " data-id="github.com/atomframework/model/Atom/Repository/Logger/Standard" data-name="atom::repository::logger::standard">
      <a href="Atom/Repository/Logger/Standard.html">Standard</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/atomframework/model/DB" data-name="db">
      <a href="DB.html">DB</a>
      
        <ul>
  
  <li class=" " data-id="github.com/atomframework/model/DB/Default" data-name="db::default">
      <a href="DB/Default.html">Default</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<blockquote>⚠️ Master branch requires Crystal master to compile. See <a href="https://crystal-lang.org/docs/installation/from_source_repository.html" target="_blank">installation instructions for Crystal</a>.</blockquote>

<h1>Atom::Model</h1>

<p><a href="https://crystal-lang.org/" target="_blank"><img src="https://img.shields.io/badge/built%20with-crystal-000000.svg?style=flat-square" alt="Built with Crystal"/></a>
<a href="https://travis-ci.org/atomframework/model" target="_blank"><img src="https://img.shields.io/travis/atomframework/model/master.svg?style=flat-square" alt="Build status"/></a>
<a href="http://api.model.atomframework.org" target="_blank"><img src="https://img.shields.io/badge/docs-available-brightgreen.svg?style=flat-square" alt="Docs"/></a>
<a href="https://github.com/atomframework/model/releases" target="_blank"><img src="https://img.shields.io/github/release/atomframework/model.svg?style=flat-square" alt="Releases"/></a>
<a href="https://github.com/veelenga/awesome-crystal" target="_blank"><img src="https://github.com/vladfaust/awesome/blob/badge-flat-alternative/media/badge-flat-alternative.svg" alt="Awesome"/></a></p>

<p>The official SQL ORM for <a href="https://github.com/atomframework/atom" target="_blank">Atom Framework</a>.</p>

<h2>Projects using Atom::Model</h2>

<ul><li><a href="https://crystaljobs.org" target="_blank">Crystal Jobs</a></li><li><a href="https://github.com/vladfaust/crystalworld" target="_blank">Crystal World</a></li><li><em>add yours!</em></li></ul>

<h2>About</h2>

<p>Atom::Model is a <a href="https://github.com/crystal-lang/crystal-db" target="_blank">crystal-db</a> ORM which does not follow Active Record pattern, it's more like a data-mapping solution. There is a concept of Repository, which is basically a gateway to the database. For example:</p>

<pre><code class="language-crystal">repo <span class="o">=</span> <span class="t">Atom</span><span class="t">::</span><span class="t">Repository</span>.<span class="k">new</span>(db)
users <span class="o">=</span> repo.query(<span class="t">User</span>.where(id: <span class="n">42</span>)).first
users.<span class="k">class</span> <span class="c"># =&gt; User</span></code></pre>

<p>Atom::Model also has a plently of features, including:</p>

<ul><li>Expressive and <strong>type-safe</strong> Query builder, allowing to use constructions like <code>Post.join(:author).where(author: user)</code>, which turns into a plain SQL</li><li>References preloader (the example above would return a <code>Post</code> which has <code>#author = <User @id=42></code> attribute set)</li><li>Beautiful schema definition syntax</li></ul>

<p>However, Atom::Model is designed to be minimal, so it doesn't perform tasks you may got used to, for example, it doesn't do database migrations itself. You may use <a href="https://github.com/vladfaust/migrate.cr" target="_blank">migrate</a> instead. Also its Query builder is not intended to fully replace SQL but instead to help a developer to write less and safer code.</p>

<p>Also note that although Atom::Model code is designed to be abstract sutiable for any <a href="https://github.com/crystal-lang/crystal-db" target="_blank">crystal-db</a> driver, it currently works with PostgreSQL only. But it's fairly easy to implement other drivers like MySQL or SQLite (see <code>/src/model/ext/pg</code> and <code>/src/model/repository.cr</code>).</p>

<h2>Installation</h2>

<p>Add this to your application's <code>shard.yml</code>:</p>

<pre><code class="language-yaml">dependencies:
  atom-model:
    github: atomframework/model
    version: ~> 0.5.0</code></pre>

<p>This shard follows <a href="http://semver.org/" target="_blank">Semantic Versioning v2.0.0</a>, so check <a href="https://github.com/atomframework/model/releases" target="_blank">releases</a> and change the <code>version</code> accordingly.</p>

<h2>Using</h2>

<h3>Basic example</h3>

<p>Assuming following database migration:</p>

<pre><code class="language-sql">CREATE TABLE users(
  uuid UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  age INT,
  created_at TIMESTAMPTZ  NOT NULL DEFAULT NOW()
);

CREATE TABLE posts(
  id SERIAL PRIMARY KEY,
  author_uuid INT NOT NULL REFERENCES users (uuid),
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ
);</code></pre>

<p>Crystal code:</p>

<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;pg&quot;</span>
<span class="k">require</span> <span class="s">&quot;atom-model&quot;</span>

<span class="k">class</span> <span class="t">User</span>
  <span class="k">include</span> <span class="t">Atom</span><span class="t">::</span><span class="t">Model</span>

  schema users <span class="k">do</span>
    pkey uuid : <span class="t">UUID</span> <span class="c"># UUIDs are supported out of the box</span>

    <span class="k">type</span> name : <span class="t">String</span>                   <span class="c"># Has NOT NULL in the column definition</span>
    <span class="k">type</span> age : <span class="t">Union</span>(<span class="t">Int32</span> <span class="o">|</span> <span class="t">Nil</span>)        <span class="c"># Does not have NULL in the column definition</span>
    <span class="k">type</span> created_at : <span class="t">Time</span> <span class="o">=</span> <span class="t">DB</span><span class="t">::</span><span class="t">Default</span> <span class="c"># Has DEFAULT in the column definition</span>

    <span class="k">type</span> posts : <span class="t">Array</span>(<span class="t">Post</span>), foreign_key: <span class="s">&quot;author_uuid&quot;</span> <span class="c"># That is an implicit reference</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">Post</span>
  <span class="k">include</span> <span class="t">Atom</span><span class="t">::</span><span class="t">Model</span>

  schema posts <span class="k">do</span>
    pkey id : <span class="t">Int32</span>

    <span class="k">type</span> author : <span class="t">User</span>, key: <span class="s">&quot;author_id&quot;</span> <span class="c"># That is an explicit reference</span>
    <span class="k">type</span> content : <span class="t">String</span>

    <span class="k">type</span> created_at : <span class="t">Time</span> <span class="o">=</span> <span class="t">DB</span><span class="t">::</span><span class="t">Default</span>
    <span class="k">type</span> updated_at : <span class="t">Union</span>(<span class="t">Time</span> <span class="o">|</span> <span class="t">Nil</span>)
  <span class="k">end</span>
<span class="k">end</span>

logger <span class="o">=</span> <span class="t">Atom</span><span class="t">::</span><span class="t">Repository</span><span class="t">::</span><span class="t">Logger</span><span class="t">::</span><span class="t">IO</span>.<span class="k">new</span>(<span class="t">STDOUT</span>)
repo <span class="o">=</span> <span class="t">Atom</span><span class="t">::</span><span class="t">Repository</span>.<span class="k">new</span>(<span class="t">DB</span>.open(<span class="t">ENV</span>[<span class="s">&quot;DATABASE_URL&quot;</span>]), logger)

<span class="c"># Most of the query builder methods (e.g. insert) are type-safe</span>
user <span class="o">=</span> repo.query(<span class="t">User</span>.insert(name: <span class="s">&quot;Vlad&quot;</span>)).first

<span class="c"># You can use object-oriented approach as well</span>
post <span class="o">=</span> <span class="t">Post</span>.<span class="k">new</span>(author: user, content: <span class="s">&quot;What a beauteful day!&quot;</span>) <span class="c"># Oops</span>

post <span class="o">=</span> repo.query(post.insert).first
<span class="c"># Logging to STDOUT:</span>
<span class="c"># [postgresql] INSERT INTO posts (author_uuid, content) VALUES (?, ?) RETURNING *</span>
<span class="c"># 1.708ms</span>
<span class="c"># [map] Post</span>
<span class="c"># 126μs</span>

<span class="c"># #to_s returns raw SQL string, so for superiour performance you may want to store it in constants</span>
<span class="t">QUERY</span> <span class="o">=</span> <span class="t">Post</span>.update.set(content: <span class="s">&quot;placeholder&quot;</span>).where(id: <span class="n">0</span>).to_s
<span class="c"># UPDATE posts SET content = ? WHERE (id = ?)</span>

<span class="c"># However, such approach doesn&#39;t check for incoming params types, `post.id` could be anything</span>
repo.exec(<span class="t">QUERY</span>, <span class="s">&quot;What a beautiful day!&quot;</span>, post.id)

<span class="c"># Join with preloading references!</span>
posts <span class="o">=</span> repo.query(<span class="t">Post</span>.where(author: user).join(<span class="n">:author</span>, <span class="k">select</span>: {<span class="s">&quot;uuid&quot;</span>, <span class="s">&quot;name&quot;</span>}))

puts posts.first.inspect
<span class="c"># =&gt; &lt;Post @id=42 @author=&lt;User @name=&quot;Vlad&quot; @uuid=&quot;...&quot;&gt; @content=&quot;What a beautiful day!&quot;&gt;</span></code></pre>

<h3>With <a href="https://github.com/atomframework/atom" target="_blank">Atom</a></h3>

<p>Define your models just as above, but with <a href="https://github.com/vladfaust/validations.cr" target="_blank"><code>Validations</code></a> included by default. You also don't need to initialize repository explicitly when using Atom:</p>

<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;pg&quot;</span>
<span class="k">require</span> <span class="s">&quot;atom&quot;</span>
<span class="k">require</span> <span class="s">&quot;atom/model&quot;</span>

<span class="k">class</span> <span class="t">User</span>
  <span class="k">include</span> <span class="t">Atom</span><span class="t">::</span><span class="t">Model</span>

  schema <span class="k">do</span>
    <span class="k">type</span> name : <span class="t">String</span>
  <span class="k">end</span>

  validate name, size: (<span class="n">3</span>..<span class="n">50</span>)
<span class="k">end</span>

users <span class="o">=</span> <span class="t">Atom</span>.query(<span class="t">User</span>.all) <span class="c"># Atom-level `query`, `exec` and `scalar` methods</span>
<span class="t">User</span>.<span class="k">new</span>(<span class="s">&quot;Jo&quot;</span>).valid?        <span class="c"># Validations</span></code></pre>

<h2>Testing</h2>

<ol><li>Run generic specs with <code>crystal spec</code></li><li>Apply migrations from <code>./db_spec/*/migration.sql</code></li><li>Run DB-specific specs with <code>env POSTGRESQL_URL=postgres://postgres:postgres@localhost:5432/model crystal spec db_spec</code></li><li>Optionally run benchmarks with <code>crystal bench.cr --release</code></li></ol>

<h2>Contributing</h2>

<ol><li>Fork it ( https://github.com/atomframework/model/fork )</li><li>Create your feature branch (git checkout -b my-new-feature)</li><li>Commit your changes (git commit -am 'Add some feature')</li><li>Push to the branch (git push origin my-new-feature)</li><li>Create a new Pull Request</li></ol>

<h2>Contributors</h2>

<ul><li><a href="https://github.com/vladfaust" target="_blank">@vladfaust</a> Vlad Faust - creator, maintainer</li></ul>
</div>
</body>
</html>
